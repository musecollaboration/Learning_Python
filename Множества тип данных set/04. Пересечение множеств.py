
# ? Пересечение множеств

# ? Пересечение ( от английского intersection) множеств позволяет определить какие элементы присутствуют одновременно в указанных множествах. В математике пересечение множеств A и В обозначается так A∩B

# В реальной жизни при помощи пересечения вы можете определить список общих друзей в социальной сети с другим пользователем. За кружочек слева А мы можем обозначить множества ваших друзей, за кружок справа B - множество друзей другого пользователя.

# * Если два множества не имеют общих элементов, то говорят, что эти множества не пересекаются. Или другими словами, пересечение этих множеств является пустым множеством

a = {4, 3, 2, 1}
b = {3, 4, 5, 6, 7}
c = {10, 11, 12}
print(a & b)        # {3, 4}
print(a & c)        # set()
# Множества при этом не изменяются
print(a, b)  # {1, 2, 3, 4} {3, 4, 5, 6, 7}


# Если необходимо изменить множества то нужно выполнить следующее
a = {4, 3, 2, 1}
b = {3, 4, 5, 6, 7}
c = {10, 11, 12}

a &= b
print(a, b)  # {3, 4} {3, 4, 5, 6, 7}
a &= c
print(a, c)  # set() {10, 11, 12}


print('-'*20)


# ? .intersection()
# Позволяет выполнить операцию пересечения.
# Метод может принимать произвольное количество любых объектов, поддерживающих итерацию по своим элементам.
# * Результатом вызова метода будет новое множество куда войдут только те элементы, которые встречаются во всех коллекциях.
# * Старые объекты никак не изменятся в процессе работы этого метода
set_a = {'car', 'test', 'bus'}
set_b = {'bus', 'soup', 'test'}
set_num = {1, 2, 3}
new_set = set_a.intersection(set_b)
print(set_a)       # {'car', 'test', 'bus'}
print(new_set)     # {'bus', 'test'}

print('-'*15)

new_set_2 = set_a.intersection(('hello', 'test'), ['test', 'soup'])
print(set_a)       # {'car', 'test', 'bus'}
print(new_set_2)   # {'test'}

print('-'*15)

print(set_num.intersection(range(3), (2, 3, 4, 5)))   # {2}


print('-'*20)


# ?  .intersection_update()
# Позволяет выполнить операцию пересечения.
# Метод может принимать произвольное количество любых объектов, поддерживающих итерацию по своим элементам.
# * Результатом вызова метода будет не создание нового множества, а изменение существующего.
# * Присваивать ничего не нужно, автоматически после вызова изменится множество, у которого данный метод был вызван.
# * При попытке сохранить результат вызова этого метода  в переменную, в ней сохранится значение
set_a = {'car', 'test_2', 'test_1'}
set_b = {'test_1', 'test_2'}

set_a.intersection_update(set_b)
print(set_a)         # {'test_2', 'test_1'}
print(set_b)         # {'test_2', 'test_1'}
print('-'*15)

set_num_1 = {1, 2, 3, 4}
set_num_2 = {2, 3, 4, 5, 6}
set_num_3 = {3, 4, 6}
res = set_num_2.intersection_update(set_num_1, set_num_3)
print(set_num_1)    # {1, 2, 3, 4}
print(set_num_2)    # {3, 4}
print(set_num_3)    # {3, 4, 6}
